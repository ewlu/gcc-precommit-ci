name: Patchworks

on:
  schedule:
    # Run every 15 minutes offset by 7 to try to avoid github's high-load times
    # https://stackoverflow.com/questions/59560214/github-action-works-on-push-but-not-scheduled
    - cron: 7,22,37,52 * * * *
  workflow_call:
    inputs:
      timestamp:
        description: 'Patch Timestamp (UTC)'
        type: string
      baseline_gcc_hash:
        description: 'Baseline hash'
        type: string
      tip_of_tree_hash:
        description: 'Trunk hash'
        type: string
      patch_id:
        description: 'Patch id (patch series not supported)'
        type: string
  workflow_dispatch:
    branches:
      - main
    inputs:
      timestamp:
        description: 'Patch Timestamp (UTC)'
        required: true
      baseline_gcc_hash:
        description: 'Baseline hash'
        required: false
      tip_of_tree_hash:
        description: 'Trunk hash'
        required: false
      patch_id:
        description: 'Patch id (patch series not supported)'
        required: false

jobs:
  fetch_patches:
    # This is a dedicated self hosted runner that will always* run this on time
    runs-on: [self-hosted, ping]
    defaults:
      run:
        working-directory: riscv-gnu-toolchain
    steps:
      - name: Cleanup build folder
        working-directory: ./
        run: |
          ls -la ./
          rm -rf ./* || true
          rm -rf ./.??* || true
          ls -la ./

      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Install dependencies
        run: |
          sudo apt install python3 -y
          sudo apt install python-is-python3 -y
          sudo apt install zip -y

      - name: Get timestamps and make directories
        if: ${{ inputs.timestamp == '' }}
        run: |
          TZ=UTC date -d "@$((($(date +%s) + 0) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > current_time_rounded.txt
          python scripts/get_previous_timestamp.py -token ${{ secrets.GITHUB_TOKEN }} -rid ${{ github.run_id }} -repo ewlu/gcc-precommit-ci -workflow Patchworks
          PRIOR_RUN_TIME=$(cat date_prior.txt)
          TZ=UTC date -d "@$((($(date -d $PRIOR_RUN_TIME +%s) + 0) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > prior_run_time_rounded.txt
          TZ=UTC date -d "@$((($(date -d $PRIOR_RUN_TIME +%s) - 900) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > prior_run_time_minus_15_min_rounded.txt

          cat runs.log

          echo $PRIOR_RUN_TIME
          cat prior_run_time_minus_15_min_rounded.txt
          cat prior_run_time_rounded.txt
          cat current_time_rounded.txt

      - name: Update times for workflow dispatch
        if: ${{ inputs.timestamp != '' }}
        run: |
          TZ=UTC date -d "@$((($(date -d '${{ inputs.timestamp }}' +%s) + 900) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > current_time_rounded.txt
          TZ=UTC date -d "@$((($(date -d '${{ inputs.timestamp }}' +%s) - 900) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > prior_run_time_rounded.txt
          TZ=UTC date -d "@$((($(date -d '${{ inputs.timestamp }}' +%s) - 1800) / 900 * 900))" '+%Y-%m-%dT%H:%M:%S' > prior_run_time_minus_15_min_rounded.txt

          cat prior_run_time_minus_15_min_rounded.txt
          cat prior_run_time_rounded.txt
          cat current_time_rounded.txt

      - name: Get list of new patches
        run: |
          mkdir -p patch_urls
          mkdir -p patchworks_metadata
          if [ "${{ inputs.patch_id }}" == "" ]; then
            python scripts/create_patches_files.py -backup $(cat prior_run_time_minus_15_min_rounded.txt) -start $(cat prior_run_time_rounded.txt) -end $(cat current_time_rounded.txt)
          else
            python scripts/create_patches_files.py -patch ${{ inputs.patch_id }}
          fi

      - name: List patch artifacts
        id: list_patches
        run: |
          export PATCHLIST="$(cat artifact_names.txt)"
          echo "patch_list=$PATCHLIST" >> $GITHUB_OUTPUT

      - name: Make artifact zip
        run: |
          zip -r patch_files.zip patch_urls
          zip -r patchworks_metadata_files.zip patchworks_metadata

      - name: Upload patch urls zip
        if: ${{ steps.list_patches.outputs.patch_list != '[]' }}
        uses: actions/upload-artifact@v3
        with:
          name: patch_urls
          path: |
            riscv-gnu-toolchain/patch_files.zip
          retention-days: 90

      - name: Upload patchworks metadata zip
        if: ${{ steps.list_patches.outputs.patch_list != '[]' }}
        uses: actions/upload-artifact@v3
        with:
          name: patchworks_metadata_files
          path: |
            riscv-gnu-toolchain/patchworks_metadata_files.zip
          retention-days: 90

    outputs:
      list_of_patch_names: ${{ steps.list_patches.outputs.patch_list }}


  init-submodules:
    needs: [fetch_patches]
    if: ${{ needs.fetch_patches.outputs.list_of_patch_names != '[]' }}
    runs-on: ubuntu-20.04
    defaults:
      run:
        working-directory: riscv-gnu-toolchain

    steps:
      - uses: actions/checkout@v3

      - name: Setup env
        uses: ./.github/actions/common/setup-env
        with:
          free_up_space: false

      - name: Determine baseline
        id: baseline-hash
        run: |
          python ./scripts/get_baseline_hash.py -token ${{ secrets.GITHUB_TOKEN }}

          if [ '${{ inputs.baseline_gcc_hash }}' == '' ] ; then export BASELINE_HASH=$(cat baseline.txt); else export BASELINE_HASH=${{ inputs.baseline_gcc_hash }}; fi
          echo $BASELINE_HASH
          echo "baseline_hash=$BASELINE_HASH" >> $GITHUB_OUTPUT

      # https://stackoverflow.com/questions/24750215/getting-the-last-commit-hash-from-a-remote-repo-without-cloning
      - name: Determine tip-of-tree hash
        id: tot-hash
        run: |
          if [ '${{ inputs.tip_of_tree_hash }}' == '' ];
          then
            export TOT_HASH=$(git ls-remote https://gcc.gnu.org/git/gcc.git HEAD | awk '{ print $1 }')
          else
            export TOT_HASH=${{ inputs.tip_of_tree_hash }}
          fi
          echo $TOT_HASH
          echo "tot_hash=$TOT_HASH" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Determine tip-of-tree-hash retry
        id: tot-retry
        if: ${{ steps.tot-hash.outcome == 'failure' }}
        run: |
          # No need to see if inputs.tip_of_tree_hash is empty string since the only way we'll enter
          # this step is if we get an error from the git ls-remote command
          echo "retrying to get tip of tree hash due to git error"
          sleep 60
          export TOT_HASH=$(git ls-remote https://gcc.gnu.org/git/gcc.git HEAD | awk '{ print $1 }')
          echo $TOT_HASH
          echo "tot_hash=$TOT_HASH" >> $GITHUB_OUTPUT

      - name: Effective tip-of-tree-hash
        id: etot-hash
        run: |
          if [ '${{ steps.tot-hash.outputs.tot_hash }}' == '' ];
          then
            echo "tot_hash=${{ steps.tot-retry.outputs.tot_hash }}" >> $GITHUB_OUTPUT
          else
            echo "tot_hash=${{ steps.tot-hash.outputs.tot_hash }}" >> $GITHUB_OUTPUT
          fi

    outputs:
      baseline_hash: ${{ steps.baseline-hash.outputs.baseline_hash }}
      tot_hash: ${{ steps.etot-hash.outputs.tot_hash }}


  patch_matrix:
    needs: [fetch_patches, init-submodules]
    strategy:
      fail-fast: false
      matrix:
        patch_name: ${{ fromJSON(needs.fetch_patches.outputs.list_of_patch_names) }}
    uses: ./.github/workflows/run-checks.yaml
    permissions:
      issues: write
    with:
      patch_name: ${{ matrix.patch_name }}
      baseline_hash: ${{ needs.init-submodules.outputs.baseline_hash }}
      tot_hash: ${{ needs.init-submodules.outputs.tot_hash }}
    secrets: inherit
